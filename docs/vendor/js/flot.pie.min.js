
/* Flot.Pie */
!function(a) {
    function d(d) {
        function n(b, c, d) {
            k || (k = !0,
            e = b.getCanvas(),
            f = a(e).parent(),
            g = b.getOptions(),
            b.setData(o(b.getData())))
        }
        function o(b) {
            for (var c = 0, d = 0, e = 0, f = g.series.pie.combine.color, h = [], i = 0; i < b.length; ++i) {
                var j = b[i].data;
                a.isArray(j) && 1 == j.length && (j = j[0]),
                a.isArray(j) ? !isNaN(parseFloat(j[1])) && isFinite(j[1]) ? j[1] = +j[1] : j[1] = 0 : j = !isNaN(parseFloat(j)) && isFinite(j) ? [1, +j] : [1, 0],
                b[i].data = [j]
            }
            for (var i = 0; i < b.length; ++i)
                c += b[i].data[0][1];
            for (var i = 0; i < b.length; ++i) {
                var j = b[i].data[0][1];
                j / c <= g.series.pie.combine.threshold && (d += j,
                e++,
                f || (f = b[i].color))
            }
            for (var i = 0; i < b.length; ++i) {
                var j = b[i].data[0][1];
                (e < 2 || j / c > g.series.pie.combine.threshold) && h.push(a.extend(b[i], {
                    data: [[1, j]],
                    color: b[i].color,
                    label: b[i].label,
                    angle: j * Math.PI * 2 / c,
                    percent: j / (c / 100)
                }))
            }
            return e > 1 && h.push({
                data: [[1, d]],
                color: f,
                label: g.series.pie.combine.label,
                angle: d * Math.PI * 2 / c,
                percent: d / (c / 100)
            }),
            h
        }
        function p(d, e) {
            function s() {
                l.clearRect(0, 0, m, n),
                f.children().filter(".pieLabel, .pieLabelBackground").remove()
            }
            function t() {
                var a = g.series.pie.shadow.left
                  , b = g.series.pie.shadow.top
                  , c = 10
                  , d = g.series.pie.shadow.alpha
                  , e = g.series.pie.radius > 1 ? g.series.pie.radius : h * g.series.pie.radius;
                if (!(e >= m / 2 - a || e * g.series.pie.tilt >= n / 2 - b || e <= c)) {
                    l.save(),
                    l.translate(a, b),
                    l.globalAlpha = d,
                    l.fillStyle = "#000",
                    l.translate(i, j),
                    l.scale(1, g.series.pie.tilt);
                    for (var f = 1; f <= c; f++)
                        l.beginPath(),
                        l.arc(0, 0, e, 0, 2 * Math.PI, !1),
                        l.fill(),
                        e -= f;
                    l.restore()
                }
            }
            function u() {
                function k(a, b, e) {
                    a <= 0 || isNaN(a) || (e ? l.fillStyle = b : (l.strokeStyle = b,
                    l.lineJoin = "round"),
                    l.beginPath(),
                    Math.abs(a - 2 * Math.PI) > 1e-9 && l.moveTo(0, 0),
                    l.arc(0, 0, c, d, d + a / 2, !1),
                    l.arc(0, 0, c, d + a / 2, d + a, !1),
                    l.closePath(),
                    d += a,
                    e ? l.fill() : l.stroke())
                }
                function o() {
                    function k(b, c, e) {
                        if (0 == b.data[0][1])
                            return !0;
                        var k, h = g.legend.labelFormatter, l = g.series.pie.label.formatter;
                        k = h ? h(b.label, b) : b.label,
                        l && (k = l(k, b));
                        var o = (c + b.angle + c) / 2
                          , p = i + Math.round(Math.cos(o) * d)
                          , q = j + Math.round(Math.sin(o) * d) * g.series.pie.tilt
                          , r = "<span class='pieLabel' id='pieLabel" + e + "' style='position:absolute;top:" + q + "px;left:" + p + "px;'>" + k + "</span>";
                        f.append(r);
                        var s = f.children("#pieLabel" + e)
                          , t = q - s.height() / 2
                          , u = p - s.width() / 2;
                        if (s.css("top", t),
                        s.css("left", u),
                        0 - t > 0 || 0 - u > 0 || n - (t + s.height()) < 0 || m - (u + s.width()) < 0)
                            return !1;
                        if (0 != g.series.pie.label.background.opacity) {
                            var v = g.series.pie.label.background.color;
                            null == v && (v = b.color);
                            var w = "top:" + t + "px;left:" + u + "px;";
                            a("<div class='pieLabelBackground' style='position:absolute;width:" + s.width() + "px;height:" + s.height() + "px;" + w + "background-color:" + v + ";'></div>").css("opacity", g.series.pie.label.background.opacity).insertBefore(s)
                        }
                        return !0
                    }
                    for (var c = b, d = g.series.pie.label.radius > 1 ? g.series.pie.label.radius : h * g.series.pie.label.radius, e = 0; e < p.length; ++e) {
                        if (p[e].percent >= 100 * g.series.pie.label.threshold && !k(p[e], c, e))
                            return !1;
                        c += p[e].angle
                    }
                    return !0
                }
                var b = Math.PI * g.series.pie.startAngle
                  , c = g.series.pie.radius > 1 ? g.series.pie.radius : h * g.series.pie.radius;
                l.save(),
                l.translate(i, j),
                l.scale(1, g.series.pie.tilt),
                l.save();
                for (var d = b, e = 0; e < p.length; ++e)
                    p[e].startAngle = d,
                    k(p[e].angle, p[e].color, !0);
                if (l.restore(),
                g.series.pie.stroke.width > 0) {
                    l.save(),
                    l.lineWidth = g.series.pie.stroke.width,
                    d = b;
                    for (var e = 0; e < p.length; ++e)
                        k(p[e].angle, g.series.pie.stroke.color, !1);
                    l.restore()
                }
                return q(l),
                l.restore(),
                !g.series.pie.label.show || o()
            }
            if (f) {
                var m = d.getPlaceholder().width()
                  , n = d.getPlaceholder().height()
                  , o = f.children().filter(".legend").children().width() || 0;
                l = e,
                k = !1,
                h = Math.min(m, n / g.series.pie.tilt) / 2,
                j = n / 2 + g.series.pie.offset.top,
                i = m / 2,
                "auto" == g.series.pie.offset.left ? (g.legend.position.match("w") ? i += o / 2 : i -= o / 2,
                i < h ? i = h : i > m - h && (i = m - h)) : i += g.series.pie.offset.left;
                var p = d.getData()
                  , r = 0;
                do
                    r > 0 && (h *= c),
                    r += 1,
                    s(),
                    g.series.pie.tilt <= .8 && t();
                while (!u() && r < b);r >= b && (s(),
                f.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>")),
                d.setSeries && d.insertLegend && (d.setSeries(p),
                d.insertLegend())
            }
        }
        function q(a) {
            if (g.series.pie.innerRadius > 0) {
                a.save();
                var b = g.series.pie.innerRadius > 1 ? g.series.pie.innerRadius : h * g.series.pie.innerRadius;
                a.globalCompositeOperation = "destination-out",
                a.beginPath(),
                a.fillStyle = g.series.pie.stroke.color,
                a.arc(0, 0, b, 0, 2 * Math.PI, !1),
                a.fill(),
                a.closePath(),
                a.restore(),
                a.save(),
                a.beginPath(),
                a.strokeStyle = g.series.pie.stroke.color,
                a.arc(0, 0, b, 0, 2 * Math.PI, !1),
                a.stroke(),
                a.closePath(),
                a.restore()
            }
        }
        function r(a, b) {
            for (var c = !1, d = -1, e = a.length, f = e - 1; ++d < e; f = d)
                (a[d][1] <= b[1] && b[1] < a[f][1] || a[f][1] <= b[1] && b[1] < a[d][1]) && b[0] < (a[f][0] - a[d][0]) * (b[1] - a[d][1]) / (a[f][1] - a[d][1]) + a[d][0] && (c = !c);
            return c
        }
        function s(a, b) {
            for (var g, k, c = d.getData(), e = d.getOptions(), f = e.series.pie.radius > 1 ? e.series.pie.radius : h * e.series.pie.radius, m = 0; m < c.length; ++m) {
                var n = c[m];
                if (n.pie.show) {
                    if (l.save(),
                    l.beginPath(),
                    l.moveTo(0, 0),
                    l.arc(0, 0, f, n.startAngle, n.startAngle + n.angle / 2, !1),
                    l.arc(0, 0, f, n.startAngle + n.angle / 2, n.startAngle + n.angle, !1),
                    l.closePath(),
                    g = a - i,
                    k = b - j,
                    l.isPointInPath) {
                        if (l.isPointInPath(a - i, b - j))
                            return l.restore(),
                            {
                                datapoint: [n.percent, n.data],
                                dataIndex: 0,
                                series: n,
                                seriesIndex: m
                            }
                    } else {
                        var o = f * Math.cos(n.startAngle)
                          , p = f * Math.sin(n.startAngle)
                          , q = f * Math.cos(n.startAngle + n.angle / 4)
                          , s = f * Math.sin(n.startAngle + n.angle / 4)
                          , t = f * Math.cos(n.startAngle + n.angle / 2)
                          , u = f * Math.sin(n.startAngle + n.angle / 2)
                          , v = f * Math.cos(n.startAngle + n.angle / 1.5)
                          , w = f * Math.sin(n.startAngle + n.angle / 1.5)
                          , x = f * Math.cos(n.startAngle + n.angle)
                          , y = f * Math.sin(n.startAngle + n.angle)
                          , z = [[0, 0], [o, p], [q, s], [t, u], [v, w], [x, y]]
                          , A = [g, k];
                        if (r(z, A))
                            return l.restore(),
                            {
                                datapoint: [n.percent, n.data],
                                dataIndex: 0,
                                series: n,
                                seriesIndex: m
                            }
                    }
                    l.restore()
                }
            }
            return null
        }
        function t(a) {
            v("plothover", a)
        }
        function u(a) {
            v("plotclick", a)
        }
        function v(a, b) {
            var c = d.offset()
              , e = parseInt(b.pageX - c.left)
              , h = parseInt(b.pageY - c.top)
              , i = s(e, h);
            if (g.grid.autoHighlight)
                for (var j = 0; j < m.length; ++j) {
                    var k = m[j];
                    k.auto != a || i && k.series == i.series || x(k.series)
                }
            i && w(i.series, a);
            var l = {
                pageX: b.pageX,
                pageY: b.pageY
            };
            f.trigger(a, [l, i])
        }
        function w(a, b) {
            var c = y(a);
            c == -1 ? (m.push({
                series: a,
                auto: b
            }),
            d.triggerRedrawOverlay()) : b || (m[c].auto = !1)
        }
        function x(a) {
            null == a && (m = [],
            d.triggerRedrawOverlay());
            var b = y(a);
            b != -1 && (m.splice(b, 1),
            d.triggerRedrawOverlay())
        }
        function y(a) {
            for (var b = 0; b < m.length; ++b) {
                var c = m[b];
                if (c.series == a)
                    return b
            }
            return -1
        }
        function z(a, b) {
            function f(a) {
                a.angle <= 0 || isNaN(a.angle) || (b.fillStyle = "rgba(255, 255, 255, " + c.series.pie.highlight.opacity + ")",
                b.beginPath(),
                Math.abs(a.angle - 2 * Math.PI) > 1e-9 && b.moveTo(0, 0),
                b.arc(0, 0, d, a.startAngle, a.startAngle + a.angle / 2, !1),
                b.arc(0, 0, d, a.startAngle + a.angle / 2, a.startAngle + a.angle, !1),
                b.closePath(),
                b.fill())
            }
            var c = a.getOptions()
              , d = c.series.pie.radius > 1 ? c.series.pie.radius : h * c.series.pie.radius;
            b.save(),
            b.translate(i, j),
            b.scale(1, c.series.pie.tilt);
            for (var e = 0; e < m.length; ++e)
                f(m[e].series);
            q(b),
            b.restore()
        }
        var e = null
          , f = null
          , g = null
          , h = null
          , i = null
          , j = null
          , k = !1
          , l = null
          , m = [];
        d.hooks.processOptions.push(function(a, b) {
            b.series.pie.show && (b.grid.show = !1,
            "auto" == b.series.pie.label.show && (b.legend.show ? b.series.pie.label.show = !1 : b.series.pie.label.show = !0),
            "auto" == b.series.pie.radius && (b.series.pie.label.show ? b.series.pie.radius = .75 : b.series.pie.radius = 1),
            b.series.pie.tilt > 1 ? b.series.pie.tilt = 1 : b.series.pie.tilt < 0 && (b.series.pie.tilt = 0))
        }),
        d.hooks.bindEvents.push(function(a, b) {
            var c = a.getOptions();
            c.series.pie.show && (c.grid.hoverable && b.unbind("mousemove").mousemove(t),
            c.grid.clickable && b.unbind("click").click(u))
        }),
        d.hooks.processDatapoints.push(function(a, b, c, d) {
            var e = a.getOptions();
            e.series.pie.show && n(a, b, c, d)
        }),
        d.hooks.drawOverlay.push(function(a, b) {
            var c = a.getOptions();
            c.series.pie.show && z(a, b)
        }),
        d.hooks.draw.push(function(a, b) {
            var c = a.getOptions();
            c.series.pie.show && p(a, b)
        })
    }
    var b = 10
      , c = .95
      , e = {
        series: {
            pie: {
                show: !1,
                radius: "auto",
                innerRadius: 0,
                startAngle: 1.5,
                tilt: 1,
                shadow: {
                    left: 5,
                    top: 15,
                    alpha: .02
                },
                offset: {
                    top: 0,
                    left: "auto"
                },
                stroke: {
                    color: "#fff",
                    width: 1
                },
                label: {
                    show: "auto",
                    formatter: function(a, b) {
                        return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + b.color + ";'>" + a + "<br/>" + Math.round(b.percent) + "%</div>"
                    },
                    radius: 1,
                    background: {
                        color: null ,
                        opacity: 0
                    },
                    threshold: 0
                },
                combine: {
                    threshold: -1,
                    color: null ,
                    label: "Other"
                },
                highlight: {
                    opacity: .5
                }
            }
        }
    };
    a.plot.plugins.push({
        init: d,
        options: e,
        name: "pie",
        version: "1.1"
    })
}(jQuery);